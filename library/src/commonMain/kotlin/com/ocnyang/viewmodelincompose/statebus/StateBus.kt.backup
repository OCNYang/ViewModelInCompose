/*
 * StateBus - Production-Ready State Management for Compose
 *
 * 生产级别的状态管理工具，支持：
 * 1. ✅ 自动追踪监听者数量
 * 2. ✅ 自动资源清理（当监听者数量为 0 时）
 * 3. ✅ 线程安全（ConcurrentHashMap + AtomicInteger）
 * 4. ✅ 配置更改恢复（ViewModel 自动保留）
 * 5. ✅ 进程死亡恢复（SavedStateHandle 自动恢复）
 * 6. ✅ 生命周期完全对齐（两级 ViewModel 架构）
 */

package com.app.base.common.statebus

import androidx.compose.runtime.Composable
import androidx.compose.runtime.MutableState
import androidx.compose.runtime.State
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
import androidx.lifecycle.SavedStateHandle
import androidx.lifecycle.ViewModel
import androidx.lifecycle.ViewModelProvider
import androidx.lifecycle.createSavedStateHandle
import androidx.lifecycle.viewmodel.CreationExtras
import androidx.lifecycle.viewmodel.compose.viewModel
import java.util.concurrent.ConcurrentHashMap
import java.util.concurrent.atomic.AtomicInteger

/**
 * StateBus - 页面间状态传递和共享的解决方案
 *
 * 基于 ViewModel 实现，特点：
 * - 自动追踪监听者数量，无监听者时自动清理
 * - 线程安全，支持多线程访问
 * - 配置更改时自动保留（ViewModel 特性）
 * - 进程死亡后自动恢复（SavedStateHandle）
 * - 两级 ViewModel 架构，生命周期完全对齐
 *
 * 架构设计：
 * ```
 * Activity/Fragment
 *   └─ StateBus (ViewModel + SavedStateHandle)  // Activity 级别
 *       └─ stateDataMap (内存缓存)
 *       └─ savedStateHandle (持久化)
 *
 * NavBackStackEntry (PageA)
 *   └─ StateBusListenerViewModel                // 页面级别
 *       └─ 注册/取消注册监听者
 * ```
 *
 * 使用示例：
 * ```kotlin
 * // 1. 创建 StateBus（绑定到 Activity/Fragment）
 * val stateBus = rememberStateBus()
 *
 * // 2. 监听状态
 * @Composable
 * fun HomeScreen() {
 *     val person = stateBus.observeState<Person?>()
 *     Text("Person: ${person?.name}")
 * }
 *
 * // 3. 设置状态
 * fun onSubmit(person: Person) {
 *     stateBus.setState<Person>(person)
 * }
 * ```
 *
 * 注意事项：
 * - 状态类型必须支持序列化（Parcelable/Serializable/基本类型）
 * - 总状态大小建议 < 1MB（Bundle 限制）
 */
class StateBus(
    @PublishedApi
    internal val savedStateHandle: SavedStateHandle
) : ViewModel() {

    /**
     * 结果数据
     * @param state 实际的状态值
     * @param listenerCount 监听者数量（线程安全的原子计数器）
     */
    @PublishedApi
    internal data class StateData(
        val state: MutableState<Any?>,
        val listenerCount: AtomicInteger
    )

    /**
     * 线程安全的状态数据 Map（内存缓存）
     *
     * 注意：使用 @PublishedApi internal，允许 inline 函数访问
     */
    @PublishedApi
    internal val stateDataMap = ConcurrentHashMap<String, StateData>()

    /**
     * 保存所有 state keys，用于进程死亡后恢复
     */
    @PublishedApi
    internal val stateKeys: MutableSet<String>
        get() = savedStateHandle.get<Set<String>>(STATE_KEYS_KEY)?.toMutableSet()
            ?: mutableSetOf()

    // ============ 公共 API ============

    /**
     * 观察状态（自动追踪监听者）
     *
     * 当 Composable 进入时自动注册为监听者，离开时自动取消注册。
     * 当最后一个监听者离开时，自动清理状态数据。
     *
     * 懒加载恢复：
     * - 首次访问时，如果内存中没有数据，会从 SavedStateHandle 恢复
     * - 进程死亡后重启，数据会自动恢复
     *
     * 注意事项：
     * - ⚠️ 不要在 LazyColumn/LazyRow 的 item 中直接调用
     * - ✅ 应该在外层调用，然后传递给 item
     * - ✅ key 应该保持稳定，避免不必要的重新注册
     * - ✅ 状态类型必须可序列化（Parcelable/Serializable/基本类型）
     *
     * @param stateKey 状态的唯一标识，默认使用类型名称
     * @return 状态值，如果不存在则返回 null
     */
    @Composable
    inline fun <reified T> observeState(
        stateKey: String = T::class.toString()
    ): T? {
        // 创建监听者 ViewModel，绑定到当前 Composable 的作用域（NavBackStackEntry）
        viewModel<StateBusListenerViewModel>(
            key = "StateBus_$stateKey",  // 加前缀避免冲突
            factory = StateBusListenerViewModelFactory(stateKey = stateKey, stateBus = this)
        )

        // 懒加载：首次访问时从 SavedStateHandle 恢复
        val data = stateDataMap.computeIfAbsent(stateKey) {
            val savedValue = try {
                savedStateHandle.get<T>(stateKey)
            } catch (e: Exception) {
                // 反序列化失败，返回 null
                null
            }
            StateData(
                state = mutableStateOf(savedValue),
                listenerCount = AtomicInteger(0)
            )
        }

        return data.state.value as? T
    }

    /**
     * 观察状态（返回 State 对象）
     *
     * 与 observeState() 类似，但返回 State 对象，可以用于需要 State 类型的场景。
     *
     * @param stateKey 状态的唯一标识
     * @return State<T?> 对象
     */
    @Composable
    inline fun <reified T> observeStateAsState(
        stateKey: String = T::class.toString(),
    ): State<T?> {
        viewModel<StateBusListenerViewModel>(
            key = "StateBus_$stateKey",
            factory = StateBusListenerViewModelFactory(stateKey = stateKey, stateBus = this)
        )

        // 懒加载：首次访问时从 SavedStateHandle 恢复
        val data = stateDataMap.computeIfAbsent(stateKey) {
            val savedValue = try {
                savedStateHandle.get<T>(stateKey)
            } catch (e: Exception) {
                null
            }
            StateData(
                state = mutableStateOf(savedValue),
                listenerCount = AtomicInteger(0)
            )
        }

        return remember(data.state) {
            object : State<T?> {
                override val value: T?
                    get() = data.state.value as? T
            }
        }
    }

    /**
     * 设置状态
     *
     * 线程安全：可以从任何线程调用
     *
     * 如果状态已存在，会更新值；如果不存在，会创建新的状态。
     * 所有监听此状态的 Composable 会自动重组。
     *
     * 同时会保存到 SavedStateHandle，支持进程死亡后恢复。
     *
     * @param stateKey 状态的唯一标识
     * @param state 状态值（必须支持序列化）
     */
    inline fun <reified T> setState(
        stateKey: String = T::class.toString(),
        state: T
    ) {
        val data = stateDataMap.computeIfAbsent(stateKey) {
            StateData(
                state = mutableStateOf(state),
                listenerCount = AtomicInteger(0)
            )
        }

        // 更新内存中的状态值
        data.state.value = state

        // 同步保存到 SavedStateHandle（支持进程死亡恢复）
        try {
            savedStateHandle[stateKey] = state
            val keys = stateKeys
            keys.add(stateKey)
            savedStateHandle[STATE_KEYS_KEY] = keys
        } catch (e: Exception) {
            // 序列化失败（类型不支持序列化）
            // 记录警告但不影响功能（配置更改仍然有效）
            android.util.Log.w("StateBus", "Failed to save state [$stateKey] to SavedStateHandle (type not serializable?)", e)
        }
    }

    /**
     * 手动移除状态（不管是否有监听者）
     *
     * 一般情况下不需要手动调用，系统会在没有监听者时自动清理。
     * 但在某些场景下（如显式清理敏感数据），可以手动调用。
     *
     * 同时会从 SavedStateHandle 中移除。
     *
     * @param stateKey 状态的唯一标识
     * @return 是否成功移除
     */
    inline fun <reified T> removeState(
        stateKey: String = T::class.toString()
    ): Boolean {
        val removed = stateDataMap.remove(stateKey) != null
        if (removed) {
            // 同时从 SavedStateHandle 移除
            savedStateHandle.remove<T>(stateKey)
            val keys = stateKeys
            keys.remove(stateKey)
            savedStateHandle[STATE_KEYS_KEY] = keys
        }
        return removed
    }

    /**
     * 清空所有状态
     *
     * 慎用：会清空所有状态，包括仍有监听者的状态
     * 同时会清空 SavedStateHandle 中的所有状态。
     */
    fun clearAll() {
        stateDataMap.clear()

        // 清空 SavedStateHandle
        val keys = stateKeys
        keys.forEach { savedStateHandle.remove<Any?>(it) }
        savedStateHandle.remove<Set<String>>(STATE_KEYS_KEY)
    }

    /**
     * 获取某个 key 的监听者数量
     *
     * @param stateKey 状态的唯一标识
     * @return 监听者数量
     */
    fun getListenerCount(stateKey: String): Int {
        return stateDataMap[stateKey]?.listenerCount?.get() ?: 0
    }

    /**
     * 获取所有 key 的监听者数量
     *
     * @return Map<状态Key, 监听者数量>
     */
    fun getAllListenerCounts(): Map<String, Int> {
        return stateDataMap.mapValues { it.value.listenerCount.get() }
    }

    /**
     * 获取所有状态的 key
     *
     * @return 所有状态的 key 集合
     */
    fun getAllKeys(): Set<String> {
        return stateDataMap.keys.toSet()
    }

    /**
     * 检查某个状态是否存在
     *
     * @param stateKey 状态的唯一标识
     * @return 是否存在
     */
    fun hasState(stateKey: String): Boolean {
        return stateDataMap.containsKey(stateKey)
    }

    // ============ 内部实现 ============

    /**
     * 注册监听者（线程安全）
     *
     * 由 StateBusListenerViewModel 调用
     */
    internal fun registerListener(stateKey: String) {
        val data = stateDataMap.computeIfAbsent(stateKey) {
            StateData(
                state = mutableStateOf(null),
                listenerCount = AtomicInteger(0)
            )
        }

        data.listenerCount.incrementAndGet()
    }

    /**
     * 取消注册监听者（线程安全）
     *
     * 由 StateBusListenerViewModel.onCleared() 调用
     */
    internal fun unregisterListener(stateKey: String) {
        val data = stateDataMap[stateKey] ?: return

        val newCount = data.listenerCount.decrementAndGet()

        // 当没有监听者时，自动清理
        if (newCount <= 0) {
            // 使用 compareAndSet 确保线程安全
            // 只有当计数仍然 <= 0 时才移除（防止竞态条件）
            if (data.listenerCount.get() <= 0) {
                stateDataMap.remove(stateKey)

                // 同时从 SavedStateHandle 移除
                savedStateHandle.remove<Any?>(stateKey)
                val keys = stateKeys
                keys.remove(stateKey)
                savedStateHandle[STATE_KEYS_KEY] = keys
            }
        }
    }

    /**
     * StateBus 被清理时的回调
     *
     * 当 Activity/Fragment 销毁时触发
     */
    override fun onCleared() {
        // 清空所有状态数据
        stateDataMap.clear()
        super.onCleared()
    }

    companion object {
        @PublishedApi
        internal const val STATE_KEYS_KEY = "stateBus_state_keys"
    }

}

/**
 * 监听者 ViewModel（外部类）
 *
 * 绑定到 NavBackStackEntry 的生命周期
 * 当页面从后退栈中真正移除时，才会触发 onCleared()
 *
 * 注意：这是外部类，不是 inner class，避免持有 StateBus 的隐式引用
 */
class StateBusListenerViewModel(
    private val stateKey: String,
    private val stateBus: StateBus
) : ViewModel() {

    init {
        // 注册监听者
        stateBus.registerListener(stateKey)
    }

    override fun onCleared() {
        // 取消注册监听者
        stateBus.unregisterListener(stateKey)
        super.onCleared()
    }
}

/**
 * StateBusListenerViewModel 的 Factory
 */
class StateBusListenerViewModelFactory(
    private val stateKey: String,
    private val stateBus: StateBus
) : ViewModelProvider.Factory {
    override fun <T : ViewModel> create(modelClass: Class<T>): T {
        if (modelClass.isAssignableFrom(StateBusListenerViewModel::class.java)) {
            @Suppress("UNCHECKED_CAST")
            return StateBusListenerViewModel(stateKey, stateBus) as T
        }
        throw IllegalArgumentException("Unknown ViewModel class: ${modelClass.name}")
    }
}

/**
 * 创建或获取 StateBus 实例
 *
 * StateBus 绑定到 Activity/Fragment 级别的 ViewModelStoreOwner
 * 配置更改时（如屏幕旋转）会自动保留
 * 进程死亡后会自动恢复状态（通过 SavedStateHandle）
 *
 * @return StateBus 实例
 */
@Composable
fun rememberStateBus(): StateBus {
    return viewModel<StateBus>(
        factory = object : ViewModelProvider.Factory {
            override fun <T : ViewModel> create(
                modelClass: Class<T>,
                extras: CreationExtras
            ): T {
                val savedStateHandle = extras.createSavedStateHandle()
                @Suppress("UNCHECKED_CAST")
                return StateBus(savedStateHandle) as T
            }
        }
    )
}
